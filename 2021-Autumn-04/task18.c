//Задача 04-18: Интегрирование
//Студенту Коле его преподавать мат.анализа задал проинтегрировать 9000 многочленов от одной переменной. Однако Коля очень занят, и попросил Васю помочь ему. 
//Вася не мог отказать своему лучше другу, однако он очень ленив и попросил помощи у Вас. 
//Помогите Васе сделать домашнее задание Коли и напишите программу, которая интегрирует многочлен.
//На стандартном потоке ввода задана единственная строка, длина которой не более 100000 символов. Строка представляет собой запись некоторого многочлена. 
//Многочлен состоит из одного и более одночленов. Одночлены могут быть разделены нулем или более пробелами. Переменные всех одночленов в многочлене совпадают. 
//Одночлены могут следовать в многочлене не по порядку своих степеней, в многочлене не могут присутствовать несколько одночленов одной степени.
//Каждый одночлен состоит из четырех частей. Первая часть одночлена является знаком '+' или '-'. Вторая часть одночлена -- коэффициент, целое неотрицательное число, 
//не превосходящее 1000000. Третья часть одночлена -- это переменная, записанная маленькой буквой английского алфавита. Четвертая часть -- степень, 
//записанная знаком '^', за которым следует показатель степени -- целое неотрицательное число, не превосходящее 1000000.
//Знак первого одночлена может быть опущен, в этом случае знак коэффициента положителен. Коэффициент одночлена также может отсутствовать, 
//в этом случае обязательно присутствует переменная одночлена, а коэффициент приравнивается к единице. Переменная одночлена также может отсутствовать, 
//в этом случае обязательно присутствует коэффициент одночлена, а степень переменной также отсутствует и приравнивается к нулю. 
//Степень переменной и знак степени может отсутствовать при наличии самой переменной, в этом случае степень переменной приравнивается к единице. 
//Если степень переменной присутствует, то есть также и сама переменная.
//Между знаком и коэффициентом одночлена может быть нуль или более пробелов. Коэффициент и переменная одночлена могут быть записаны подряд 
//(без пробелов) или через знак умножения '*'. В последнем случае между коэффициентом и знаком умножения, а также между знаком умножения и переменной 
//может быть нуль или более пробелов. Между переменной и знаком степени '^', а также между знаком и показателем степени не содержится пробелов.
//На стандартном потоке вывода напечатайте строку, представляющую канонический вид неопределенного интеграла для заданного многочлена. 
//Одночлены в интеграле должны идти строго в порядке уменьшения степеней и разделяться одним пробелом. 
//Одночленов с нулевыми коэффициентами не должно быть в выводе. Переменная выходного многочлена должна совпадать с переменной входного. 
//Если входной переменной не было, то выходной переменной должна быть буква 'x'.
//Знак одночлена должен присутствовать всегда, кроме одночлена наибольшей степени, если он положителен, и отделяться от коэффициента одним пробелом 
//(для одночлена наибольшей степени пробелов быть не должно). Коэффициент должен быть представлен в виде целого положительного числа 
//или рациональной несократимой дроби (с помощью знака деления '/'; знаменатель в этом случае должен быть строго больше единицы). 
//Коэффициент, равный единице, должен быть опущен. Переменная должна присутствовать только в том случае, если степень одночлена не равна нулю, 
//и записываться сразу после знака умножения без пробелов, который должен записываться после коэффициента без пробелов. 
//Степень одночлена со знаком степени должна присутствовать только в том случае, если она больше единицы, и записываться после знака степени без пробелов, 
//который должен записываться после переменной без пробелов. После последнего одночлена должна идти константа, отделенная от него одним пробелом и записанная в виде "+ C". 
//Если же последний одночлен отсутствует, выведите "C".
//Указание: int(ax^n) = (a/n+1)x^(n+1) + C, n ≥ 0, C - const

#include "stdio.h"

struct fraction
{
	int numerator;
	int denominator;
};
int nod(int a, int b)
{
	if (b == 0)
		return a;

	return nod(b, a % b);
}
void reduce(struct fraction* a)
{
	int NOD = nod(a->numerator, a->denominator);
	a->numerator /= NOD;
	a->denominator /= NOD;
}
void init_fraction(struct fraction* n, int a, int b)
{
	n->numerator = a;
	n->denominator = b;

	reduce(n);
}
struct fraction divide(struct fraction a, int n)
{
	struct fraction out;

	init_fraction(&out, a.numerator, a.denominator * n);

	return out;
}
void print_fraction(struct fraction a)
{
	if (a.denominator != 1)
		printf("%d/%d", a.numerator, a.denominator);
	else
		printf("%d", a.numerator);
}
int is_one(struct fraction a)
{
	return (a.numerator == 1 && a.denominator == 1);
}

struct monomial
{
	int sign;
	struct fraction a;
	char x;
	int n;
};
void init_monomial(struct monomial* m, int sign, struct fraction a, char x, int n)
{
	m->sign = sign;
	m->a = a;
	m->x = x;
	m->n = n;
}
struct monomial integrate(struct monomial a)
{
	struct monomial out;

	int n_ = a.n + 1;

	init_monomial(&out, a.sign, divide(a.a, n_), a.x, n_);

	return out;
}
int is_zero(struct monomial a)
{
	return !a.a.numerator;
}
void print_monomial(struct monomial a, int flag)
{
	if (!flag)
	{
		if (a.sign == 1)
			printf(" + ");
		else if (a.sign == -1)
			printf(" - ");
	}
	else if (a.sign == -1)
		printf("-");

	if (!is_one(a.a))
	{
		print_fraction(a.a);
	}

	if (a.n != 0)
	{
		if (!is_one(a.a))
			printf("*");
		printf("%c", a.x);

		if (a.n != 1)
			printf("^%d", a.n);
	}
}
int read_num(char* str, int* i)
{
	int n = 0;

	while (str[*i] >= '0' && str[*i] <= '9')
	{
		n *= 10;
		n += str[*i] - '0';
		(*i)++;
	}

	return n;
}
struct monomial monomial_read(char* str, int* i)
{
	struct monomial out;
	struct fraction a_;

	int sign = 1;
	int a = 1;
	char x = 'x';
	int n = 0;

	char c;

	c = str[*i];

	if (c == '-')
		sign = -1;

	(*i)++;
	c = str[*i];

	if (c >= '0' && c <= '9')
	{
		a = read_num(str, i);
		c = str[*i];
	}

	init_fraction(&a_, a, 1);

	if (!c)
	{
		init_monomial(&out, sign, a_, x, n);
		return out;
	}

	if (c != '+' && c != '-')
	{
		x = c;
		n = 1;

		(*i)++;
		c = str[*i];

		if (!c)
		{
			init_monomial(&out, sign, a_, x, n);
			return out;
		}

		if (c != '+' && c != '-')
			n = read_num(str, i);
	}

	init_monomial(&out, sign, a_, x, n);
	return out;
}

void add_plus(char* str)
{
	char prev;
	char cur = str[0];

	str[0] = '+';

	int i = 1;
	for (; str[i]; i++)
	{
		prev = cur;
		cur = str[i];
		str[i] = prev;
	}

	str[i] = cur;
}

char str[100005];
char expr[100005];

struct monomial polynomial[1000005];

int main(void)
{
	fgets(str, 100005, stdin);

	int j = 0;

	for (int i = 0; str[i] != '\n' && str[i]; i++)
	{
		if (str[i] != ' ' && str[i] != '*' && str[i] != '^')
		{
			expr[j] = str[i];
			j++;
		}
	}

	if (expr[0] != '-')
		add_plus(expr);

	//printf("%s\n", expr);

	j = 0;

	struct monomial cur;

	char let = 'x';

	while (expr[j])
	{
		cur = integrate(monomial_read(expr, &j));

		if (cur.x != 'x')
			let = cur.x;

		polynomial[cur.n] = cur;
	}

	int flag = 1;
	int flag2 = 0;
	
	polynomial[1].x = let;

	for (int i = 1000000; i >= 1; i--)
	{
		if (!is_zero(polynomial[i]))
		{
			flag2 = 1;
			if (flag)
			{
				flag = 0;
				
				if (polynomial[i].sign == 1)
					polynomial[i].sign = 0;

				print_monomial(polynomial[i], 1);
			}
			else
			 print_monomial(polynomial[i], 0);
		}
	}

	if(flag2)
		printf(" + C");
	else
		printf("C");

	return 0;
}
